const std = @import("std");
const colors = @import("cli/colors.zig");

const stdin = std.io.getStdIn().reader();

const Point = struct {
    .x,
    .y,
};

pub fn getNumber() ?f64 {
    var buf: [16]u8 = undefined;
    const a = stdin.readUntilDelimiter(&buf, '\n') catch |err| switch (err) {
        error.StreamTooLong => {
            std.debug.print("Yo yo shit is too long!\n", .{});
            return null;
        },
        else => {
            std.debug.panic("err: {}", .{err});
            return null;
        },
    };

    return std.fmt.parseFloat(f64, a) catch {
        std.debug.print("it aint a number nigger!\n", .{});
        return null;
    };
}

pub fn getFunction() [2]f64 {

}

pub fn main() !void {

    const slope = (y1.? - y2.?) / (x1.? - x2.?);
    const c = y1.? - slope * x1.?;

    std.debug.print(colors.comptimeTranslate("f(x) = {d}x + {d}\n"), .{ slope, c });

    //while (true) {
    //defer frame += 1;
    //try stdout.print("\x1B[2F\x1B[G\x1B[2Kcount is:\n{}\n", .{frame});
    //}

    //try stdout.print("\x1B[2F\x1B[G\x1B[2Kbye\nworld\n", .{});

    //try stdout.print("\n\n", .{});
    //try stdout.print("\x1B[2Khello world", .{});
}

test "simple test" {
    var list = std.ArrayList(i32).init(std.testing.allocator);
    defer list.deinit(); // try commenting this out and see if zig detects the memory leak!
    try list.append(42);
    try std.testing.expectEqual(@as(i32, 42), list.pop());
}
